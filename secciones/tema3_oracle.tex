% ============================================================
%  TEMA 3 — SGBD y arquitectura física: enfoque Oracle
% ============================================================
\chapter{Sistemas Gestores de Bases de Datos y arquitectura física: enfoque Oracle}

% ── 3.1 Arquitectura general ─────────────────────────────────────────────────
\section{Arquitectura general de Oracle Database}

\subsection{Distinción entre instancia y base de datos}

Antes de hablar de procesos o memoria, hay una distinción fundamental en Oracle que conviene tener clara desde el inicio: la diferencia entre la \textbf{instancia} y la \textbf{base de datos}.

La \textbf{base de datos} son los archivos en disco: datafiles, redo log files y control files. Existen independientemente de si Oracle está corriendo o no. La \textbf{instancia} es lo que ocurre en RAM cuando Oracle está activo: la SGA y los procesos en segundo plano. Es temporal; desaparece al apagar el servidor o ante una caída \parencite{oracle_concepts_19c}.

Esta separación es lo que hace posible la recuperación. Ante una falla de energía, la instancia desaparece pero los archivos permanecen intactos. Al reiniciar, Oracle lee los archivos y reconstruye el estado correcto.

\subsection{Arquitectura cliente-servidor}

Oracle separa claramente el rol del cliente y el del servidor. El cliente es la aplicación desde donde el usuario escribe consultas; el servidor es donde Oracle las procesa y accede a los datos en disco. El cliente nunca manipula los archivos directamente.

Para gestionar las conexiones entrantes existe el \textbf{Oracle Net Listener}, un proceso que escucha peticiones de conexión y las redirige al proceso servidor correspondiente. Sin el Listener activo, ningún cliente puede conectarse.

Una vez aceptada la conexión, Oracle puede atenderla en modo \textbf{servidor dedicado} (un proceso exclusivo por usuario, mejor rendimiento por sesión) o \textbf{servidor compartido} (un grupo de procesos atiende a muchos clientes de forma rotativa, más eficiente cuando hay muchas conexiones pero poca actividad continua) \parencite{oracle_concepts_19c}.

\subsection{Soporte multiusuario}

Oracle fue diseñado desde el inicio para soportar múltiples usuarios simultáneos. Cada conexión genera una sesión con su propio espacio de memoria privada en la PGA, donde se almacenan los cursores abiertos y los resultados intermedios. La actividad de un usuario no afecta la memoria de los demás.

El mayor desafío del acceso concurrente es que múltiples usuarios pueden querer modificar el mismo dato al mismo tiempo. Oracle lo resuelve con bloqueos a nivel de fila y con un modelo de consistencia de lectura basado en segmentos de undo, de modo que los lectores no bloqueen a los escritores y viceversa \parencite{oracle_concepts_19c}.

% ── 3.2 Procesos ─────────────────────────────────────────────────────────────
\section{Gestión de procesos}

\subsection{Procesos de usuario y procesos servidor}

Cuando un usuario se conecta a Oracle se generan dos procesos distintos. El \textbf{proceso de usuario} corre en la máquina del cliente y envía las instrucciones SQL. El \textbf{proceso servidor} corre en el servidor y las ejecuta, accediendo a los datos. El cliente nunca toca los archivos directamente.

\subsection{Procesos en segundo plano}

Estos procesos arrancan automáticamente al iniciar la instancia y trabajan de forma continua, independiente de los usuarios. Son el motor real de la arquitectura.

\subsubsection{DBWR — Database Writer}

Escribe los bloques modificados del buffer cache (los \textit{dirty blocks}) hacia los datafiles en disco, de forma asíncrona y agrupando escrituras para minimizar el impacto en rendimiento. Se activa ante checkpoints, cuando el buffer acumula demasiados bloques sucios, o cuando no hay espacio libre disponible \parencite{oracle_concepts_19c}.

\subsubsection{LGWR — Log Writer}

Escribe las entradas del redo log buffer hacia los redo log files en disco. Este proceso es crítico: un \texttt{COMMIT} no se considera completo hasta que LGWR confirma esa escritura. Se activa en cada commit, cuando el buffer alcanza un tercio de su capacidad, o cada tres segundos.

\subsubsection{SMON — System Monitor}

Ejecuta la recuperación de instancia al arrancar Oracle tras una caída: aplica los redo logs para recuperar cambios perdidos y deshace las transacciones que no habían sido confirmadas. También libera segmentos temporales sin uso \parencite{oracle_concepts_19c}.

\subsubsection{PMON — Process Monitor}

Detecta procesos de usuario que fallaron o se desconectaron abruptamente y libera todo lo que dejaron pendiente: memoria, bloqueos sobre filas, transacciones incompletas. Sin PMON, una desconexión abrupta podría dejar filas bloqueadas indefinidamente.

\subsubsection{CKPT — Checkpoint Process}

Registra en las cabeceras de los datafiles y en el control file la posición hasta donde los cambios fueron escritos a disco. En una recuperación, Oracle solo necesita aplicar los redo logs a partir del último checkpoint, lo que reduce significativamente el tiempo de recuperación \parencite{oracle_concepts_19c}.

\subsubsection{ARCn — Archiver}

En modo \textit{ARCHIVELOG}, copia cada redo log file lleno hacia un destino de archivo antes de que sea sobreescrito. Combinando un backup completo con los archived logs es posible restaurar la base de datos hasta cualquier punto en el tiempo.

\subsection{Manejo de concurrencia: MVCC}

Oracle utiliza \textbf{MVCC} (\textit{Multi-Version Concurrency Control}) para gestionar el acceso simultáneo. Cuando una consulta inicia, Oracle le asigna un \textbf{SCN} (\textit{System Change Number}) y garantiza que verá los datos tal como estaban en ese momento exacto. Si un bloque fue modificado por otra transacción, Oracle reconstruye su versión anterior usando los segmentos de undo.

El resultado es que \textbf{los lectores no bloquean a los escritores y viceversa}. Ambos pueden operar sobre los mismos datos de forma simultánea sin que uno espere al otro \parencite{oracle_concepts_19c}.

% ── 3.3 Memoria ──────────────────────────────────────────────────────────────
\section{Administración de memoria}

Oracle divide su memoria en dos grandes áreas: la \textbf{SGA}, compartida por todos los procesos, y la \textbf{PGA}, privada por cada proceso servidor.

\subsection{SGA — System Global Area}

Se asigna al arrancar la instancia. Oracle puede redistribuir memoria entre sus componentes automáticamente mediante AMM (\textit{Automatic Memory Management}) o ASMM (\textit{Automatic Shared Memory Management}) \parencite{oracle_admin_19c}.

\subsubsection{Buffer Cache}

Almacena copias de bloques de datos leídos desde disco. Cuando Oracle necesita un bloque, lo busca aquí primero. Si no está, lo lee del disco y lo carga. Usa un algoritmo LRU para decidir qué desalojar cuando necesita espacio. Es el componente con mayor impacto en la reducción de operaciones de entrada/salida \parencite{oracle_concepts_19c}.

\subsubsection{Shared Pool}

Contiene la \textbf{library cache}, que almacena planes de ejecución ya compilados para reutilizarlos, y el \textbf{dictionary cache}, que guarda metadatos del diccionario de datos (definiciones de tablas, permisos, etc.). Un Shared Pool bien dimensionado reduce el tiempo de procesamiento de consultas repetitivas.

\subsubsection{Redo Log Buffer}

Buffer circular donde se escriben las entradas de redo antes de que LGWR las vuelque al disco. Un buffer demasiado pequeño obliga a LGWR a escribir con mayor frecuencia, lo que puede generar un cuello de botella en sistemas con alta actividad transaccional.

\subsubsection{Large Pool}

Área opcional para operaciones que requieren bloques grandes de memoria: backups con RMAN, operaciones en modo shared server y consultas paralelas. Mantenerlas separadas del Shared Pool evita que lo fragmenten.

\subsection{PGA — Program Global Area}

Área de memoria \textbf{privada} asignada individualmente a cada proceso servidor. Contiene el estado de los cursores abiertos, información de sesión y las áreas de trabajo para ordenamientos y operaciones de hash.

Si esas operaciones no caben en la PGA, Oracle las desborda al tablespace temporal en disco, con el impacto en rendimiento que eso implica. A diferencia de la SGA, la PGA no se comparte: cada proceso tiene la suya y nadie más puede acceder a ella \parencite{oracle_concepts_19c}.

% ── 3.4 Archivos físicos ─────────────────────────────────────────────────────
\section{Organización de archivos físicos}

\subsection{Datafiles}

Son los archivos donde Oracle almacena físicamente los datos de tablas, índices y demás objetos. Cada datafile pertenece a un único tablespace, pero un tablespace puede estar compuesto por varios datafiles \parencite{oracle_concepts_19c}.

\subsection{Control Files}

Archivos pequeños pero críticos: contienen el nombre de la base de datos, el SCN actual, la ubicación de todos los datafiles y redo log files, y el historial de backups. Oracle no puede arrancar sin ellos. La práctica estándar es la \textbf{multiplexación}: mantener copias idénticas en discos físicos distintos para protegerse ante fallos de hardware \parencite{loney_oracle_12c}.

\subsection{Redo Log Files}

Registran todos los cambios realizados en la base de datos. Oracle los organiza en grupos que rota de forma circular: cuando un grupo se llena ocurre un \textit{log switch} y Oracle pasa al siguiente. Con ese switch también se dispara un checkpoint.

\subsection{Tablespaces, segmentos, extensiones y bloques}

Los \textbf{tablespaces} son la unidad lógica de almacenamiento que agrupa datafiles. Oracle crea varios por defecto: SYSTEM y SYSAUX para el diccionario de datos; TEMP para operaciones temporales; UNDO para los segmentos de undo; y USERS como espacio por defecto para objetos de usuario.

Dentro de los tablespaces, el almacenamiento se organiza en \textbf{segmentos} (el espacio asignado a un objeto concreto), \textbf{extensiones} (conjuntos contiguos de bloques que se asignan dinámicamente cuando el segmento necesita crecer) y \textbf{bloques} (la unidad mínima de lectura y escritura) \parencite{oracle_concepts_19c}.

% ── 3.5 ACID ─────────────────────────────────────────────────────────────────
\section{Cómo la arquitectura física soporta las propiedades ACID}

\subsection{Atomicidad — segmentos de undo}

Antes de aplicar cualquier cambio, Oracle guarda la versión anterior del dato en los segmentos de undo. Si la transacción falla, usa esos datos para revertirlo todo como si nada hubiera ocurrido.

\subsection{Durabilidad — redo log}

Cada cambio se registra en el redo log antes de confirmarse. Si ocurre una caída justo después de un commit, al reiniciar Oracle aplica los redo logs y recupera esos cambios aunque nunca hayan llegado a los datafiles \parencite{gray_reuter_1992}.

\subsection{Consistencia — MVCC y undo}

Cuando una consulta inicia, Oracle toma nota del SCN actual y garantiza que verá los datos tal como estaban en ese momento. Si durante la consulta otro proceso modificó un bloque, Oracle reconstruye la versión anterior usando los segmentos de undo. Cada lectura es consistente con un punto en el tiempo.

\subsection{Aislamiento — locking y MVCC}

Los escritores bloquean solo las filas que modifican. Los lectores acceden a versiones anteriores reconstruidas desde el undo sin quedar bloqueados. Ambas operaciones pueden coexistir sin conflicto.

\subsection{Recuperación ante fallos}

Al arrancar tras una caída, SMON ejecuta la recuperación en tres fases: aplica los redo logs para recuperar cambios que estaban solo en memoria (\textit{roll forward}), abre la base de datos, y deshace las transacciones que no habían sido confirmadas (\textit{roll back}) \parencite{oracle_concepts_19c}.

\clearpage