% ============================================================
%  TEMA 4 — Comparativa de estructuras físicas entre SGBD
% ============================================================
\chapter{Comparativa de estructuras físicas entre SGBD}

\section{Introducción a la comparativa}

Comparar Oracle, PostgreSQL, MySQL y SQL Server no es solo una cuestión de cuál
es más rápido o más popular. Lo que realmente importa es analizar
cómo cada uno resolvió los mismos problemas fundamentales: gestionar memoria,
procesos, archivos y transacciones. Esto desde filosofías de diseño distintas.

% ── 4.1 Arquitectura de memoria ──────────────────────────────────────────────
\section{Diferencias en la arquitectura de memoria}

\subsection{Oracle Database}

Oracle divide su memoria en
la \textbf{SGA} y la
\textbf{PGA}. La gestión puede ser automática
mediante AMM o ASMM, lo que permite a Oracle redistribuir memoria entre
componentes según la carga \citep{oracle_concepts_19c}.

\subsection{PostgreSQL}

Tiene un modelo de memoria más simple y, en parte, delega la gestión
al sistema operativo. El parámetro \texttt{shared\_buffers} define el buffer
compartido entre todos los procesos, equivalente al buffer cache de Oracle, aunque
PostgreSQL también aprovecha el \textit{OS page cache} para lecturas, por lo que
el tamaño efectivo de caché suele ser mayor que lo que indica ese parámetro solo.

Cada proceso backend tiene su propia \texttt{work\_mem}, que define cuánta memoria
puede usar para operaciones individuales de ordenamiento o hash join, análogo al
SQL Work Area de la PGA de Oracle. Existe además \texttt{maintenance\_work\_mem}
para operaciones de mantenimiento como \texttt{VACUUM} o \texttt{CREATE INDEX}, y
\texttt{wal\_buffers} como buffer en memoria antes de escribir el WAL al disco.
El parámetro \texttt{effective\_cache\_size} no reserva memoria real sino que es
una sugerencia al planificador de consultas sobre cuánta caché total estima que
hay disponible \citep{postgresql_docs}.

\subsection{MySQL / InnoDB}

En MySQL el componente central de memoria es el \textbf{InnoDB Buffer Pool},
controlado por \texttt{innodb\_buffer\_pool\_size}. Es el equivalente más directo
al buffer cache de Oracle y almacena tanto páginas de datos como de índices. Para
reducir la contención en sistemas con alta concurrencia, puede dividirse en
múltiples instancias mediante \texttt{innodb\_buffer\_pool\_instances}.

InnoDB también mantiene un \textbf{Log Buffer} (\texttt{innodb\_log\_buffer\_size})
donde acumula entradas de redo antes de escribirlas al disco, y un
\textbf{Adaptive Hash Index} que construye dinámicamente en memoria para acelerar
búsquedas repetitivas en índices de un árbol B+ \citep{mysql_docs}.

\subsection{Microsoft SQL Server}

Gestiona su memoria mediante un único \textbf{Buffer Pool} dinámico,
administrado por el componente interno \textbf{SQLOS}. Este
Buffer Pool crece y se reduce automáticamente dentro de los límites definidos por
\texttt{max server memory} y \texttt{min server memory}.

El \textbf{Plan Cache} almacena los planes de ejecución compilados, equivalente
al library cache del Shared Pool de Oracle. Una característica distintiva es
\textbf{In-Memory OLTP}, que permite definir tablas
completamente residentes en memoria con estructuras optimizadas para operaciones
transaccionales de muy alta velocidad, sin necesidad de acceder a disco durante
el procesamiento \citep{sqlserver_docs}.

% ── 4.2 Gestión de procesos ──────────────────────────────────────────────────
\section{Diferencias en la gestión de procesos}

\subsection{Oracle Database}

Oracle usa un modelo multi-proceso donde cada conexión puede tener su propio
proceso servidor dedicado, y los procesos de background como DBWR, LGWR o SMON
corren de forma independiente.

\subsection{PostgreSQL}

Sigue un modelo \textbf{multi-proceso puro}: por cada conexión que
llega, el proceso maestro \textbf{postmaster} crea un proceso hijo independiente
del sistema operativo llamado \textit{backend}. Esto significa que cien conexiones
simultáneas implican cien procesos OS corriendo en paralelo.

La ventaja de este modelo es el aislamiento, ya que un backend que falla no compromete
a los demás. La desventaja es que crear y destruir procesos tiene un costo, y
mantener muchos procesos simultáneos puede ser pesado en sistemas con miles de
conexiones concurrentes.

Los procesos auxiliares incluyen \textbf{bgwriter} (escribe páginas sucias al
disco), \textbf{walwriter} (equivalente al LGWR de Oracle), \textbf{checkpointer},
\textbf{autovacuum launcher} y sus workers, y el \textbf{stats collector}
\citep{postgresql_docs}.

\subsection{MySQL / InnoDB}

Adopta un enfoque distinto: corre como un \textbf{único proceso}
\texttt{mysqld} que maneja todas las conexiones mediante \textbf{threads internos}.
Cada conexión recibe un thread, y existe un pool de threads opcional para
reutilizarlos en lugar de crearlos y destruirlos constantemente.

Los threads de background de InnoDB incluyen el \textbf{master thread} que
coordina tareas de mantenimiento, los \textbf{I/O threads} para operaciones
asíncronas de lectura y escritura, los \textbf{purge threads} que eliminan las
versiones antiguas de filas ya no necesarias por el MVCC, y los
\textbf{page cleaner threads} que escriben páginas sucias del buffer pool al
disco \citep{mysql_docs}.

\subsection{Microsoft SQL Server}

También corre como un único proceso \texttt{sqlservr.exe} con múltiples
threads internos, pero su arquitectura de scheduling es especial.
\textbf{SQLOS} implementa un scheduler propio, lo que
significa que los threads ceden el control voluntariamente en lugar de ser
interrumpidos por el sistema operativo. Esto le da mayor control
sobre la distribución de CPU.

Los \textbf{worker threads} forman un pool que atiende las peticiones entrantes.
Otros threads especializados incluyen el \textbf{Lazy Writer}, el \textbf{Log Writer} y el \textbf{Checkpoint} thread
\citep{sqlserver_docs}.

% ── 4.3 Archivos físicos ─────────────────────────────────────────────────────
\section{Diferencias en la organización de archivos físicos}

\subsection{Oracle Database}

Oracle organiza sus archivos en datafiles \texttt{.dbf} agrupados en tablespaces,
acompañados por los control files y los redo log files.

\subsection{PostgreSQL}

Todo el almacenamiento de PostgreSQL vive bajo un directorio raíz llamado
\textbf{PGDATA}. Dentro de él, cada base de datos tiene su propio subdirectorio
identificado por un OID numérico, y dentro de ese directorio cada tabla e índice
es un archivo independiente, también identificado por su OID.

Cuando una tabla crece más de 1 GB, PostgreSQL la divide automáticamente en
segmentos del mismo tamaño. El \textbf{WAL} vive en el directorio
\texttt{pg\_wal} y funciona como el redo log de Oracle. El directorio
\texttt{pg\_xact} contiene el \textit{commit log} (CLOG), que registra el estado
de cada transacción. Los tablespaces en PostgreSQL son simplemente directorios
simbólicos en el sistema de archivos, más simples que en Oracle
\citep{postgresql_docs}.

\subsection{MySQL / InnoDB}

Ofrece dos modalidades de almacenamiento. En la modalidad tradicional, todos
los datos de InnoDB se guardan en un único archivo llamado \textbf{ibdata1}
(\textit{system tablespace}). La modalidad recomendada actualmente es
\texttt{innodb\_file\_per\_table}, donde cada tabla tiene su propio archivo
\texttt{.ibd} que contiene tanto los datos como los índices de esa tabla \citep{mysql_docs}.

\subsection{Microsoft SQL Server}

Usa una estructura de archivos clara. El archivo \textbf{.mdf} es el
archivo de datos primario de cada base de datos; si se necesita más espacio o
distribuir la carga entre discos, se agregan archivos secundarios \textbf{.ndf}.
El archivo \textbf{.ldf} contiene el log de transacciones.

Los archivos de datos se agrupan en \textbf{filegroups}, que son la unidad lógica
de almacenamiento equivalente a los tablespaces de Oracle. SQL Server también
mantiene \textbf{TempDB}, una base de datos especial compartida por todas las
bases del servidor para almacenamiento temporal, y soporta \textit{sparse files}
para implementar snapshots de base de datos \citep{sqlserver_docs}.

% ── 4.4 Manejo de logs ───────────────────────────────────────────────────────
\section{Diferencias en el manejo de logs transaccionales}

\subsection{Write-Ahead Logging (WAL) y Redo Log: principio común}

Independientemente del nombre que cada motor le dé, todos los SGBD analizados
comparten el mismo principio fundamental: los cambios se registran en un log
\textit{antes} de aplicarse a los archivos de datos. Esto garantiza que ante
una caída, el motor pueda reconstruir el estado correcto de la base de datos
reproduciendo ese log. 

\subsection{Comparativa por SGBD}

\begin{table}[H]
  \centering
  \caption{Comparativa del mecanismo de logging transaccional}
  \label{tab:logging}
  \begin{tabular}{lp{2.8cm}p{2.8cm}p{2.8cm}p{2.8cm}}
    \toprule
    \textbf{Aspecto} & \textbf{Oracle} & \textbf{PostgreSQL} & \textbf{MySQL/InnoDB} & \textbf{SQL Server} \\
    \midrule
    Nombre del log       & Redo Log       & WAL (pg\_wal)      & InnoDB Redo Log       & Transaction Log (.ldf) \\
    Proceso escritor     & LGWR           & walwriter          & Log writer thread     & Log Writer thread \\
    Formato              & Circular (grupos) & Segmentos secuenciales & Circular (8.0+ dinámico) & VLF (Virtual Log Files) \\
    Archivado            & ARCn (Archive Log Mode) & pg\_archiver / streaming replication & Binary Log (distinto) & Log Backup (FULL/BULK) \\
    PITR                 & Sí (RMAN)      & Sí (pg\_basebackup + WAL) & Sí (binlog + backup) & Sí (backup + log) \\
    \bottomrule
  \end{tabular}
  \\\small Fuente: Elaboración propia a partir de documentación oficial.
\end{table}

% ── 4.5 Tabla resumen comparativa

\begin{landscape}
\begin{table}[H]
  \centering
  \caption{Comparativa general de estructuras físicas e internas de los SGBD}
  \label{tab:comparativa_general}
  \small
  \begin{tabular}{lp{3cm}p{3cm}p{3cm}p{3cm}}
    \toprule
    \textbf{Característica}      & \textbf{Oracle Database} & \textbf{PostgreSQL} & \textbf{MySQL (InnoDB)} & \textbf{SQL Server} \\
    \midrule
    \textbf{Arquitectura de memoria}
      & SGA (compartida) + PGA (privada). AMM/ASMM.
      & shared\_buffers + work\_mem. Delega en OS page cache.
      & InnoDB Buffer Pool con instancias múltiples.
      & Buffer Pool dinámico. SQLOS. In-Memory OLTP. \\[6pt]

    \textbf{Modelo de procesos}
      & Multi-proceso con procesos background dedicados.
      & Multi-proceso (un proceso OS por conexión).
      & Mono-proceso con threads internos.
      & Mono-proceso (sqlservr.exe) con SQLOS y worker threads. \\[6pt]

    \textbf{Archivos de datos}
      & Datafiles (.dbf) agrupados en Tablespaces.
      & Archivos por relación en PGDATA/base/OID.
      & ibdata1 global o .ibd por tabla (file-per-table).
      & .mdf (primario) + .ndf (secundarios) en Filegroups. \\[6pt]

    \textbf{Log transaccional}
      & Redo Log circular (grupos). LGWR. Archivado opcional.
      & WAL (pg\_wal). walwriter. Archivado continuo.
      & InnoDB Redo Log + Binary Log (separados).
      & Transaction Log (.ldf) con VLF. \\[6pt]

    \textbf{Control de concurrencia}
      & MVCC con segmentos de Undo. Row-level locking.
      & MVCC nativo. Sin undo log separado (tuplas versión en heap).
      & MVCC con undo tablespaces. Gap locking en índices.
      & Locking tradicional + MVCC vía versiones de fila (tempdb). \\[6pt]

    \textbf{Organización interna}
      & Bloques Oracle (2–32 KB). Segmentos/Extensiones.
      & Páginas de 8 KB. TOAST para valores grandes.
      & Páginas InnoDB de 16 KB. B+Tree clustered index.
      & Páginas de 8 KB. Extents de 64 KB. Heap o clustered. \\
    \bottomrule
  \end{tabular}
  \\\small Fuente: Elaboración propia a partir de documentación oficial de cada SGBD.
\end{table}
\end{landscape}

% ============================================================
%  TEMA 4 — Sección: Ventajas y desventajas estructurales
%  (reemplaza la sección \section{Ventajas y desventajas estructurales}
%   al final de tema4_comparativa.tex)
% ============================================================

\section{Ventajas y desventajas estructurales}

\subsection{Oracle Database}

Oracle es el motor más maduro del grupo y eso se nota. Características como RAC para clustering nativo o ASM para gestión de almacenamiento son el resultado de décadas resolviendo problemas reales en producción, no de diseño en papel. Su sistema de recuperación ante fallos es robusto y está bien documentado, lo que en entornos críticos vale mucho.

El problema es que toda esa madurez tiene un precio, y no solo en licenciamiento. Administrar Oracle correctamente requiere conocimientos especializados que no son fáciles de conseguir ni baratos. Una instancia mal configurada consume recursos considerables incluso sin carga. Para una organización pequeña o un proyecto con presupuesto ajustado, Oracle puede ser demasiado para lo que se necesita \parencite{greenwald_oracle}.

\subsection{PostgreSQL}

Lo que más llama la atención de PostgreSQL desde el punto de vista arquitectónico es cómo implementa el MVCC. En lugar de mantener un segmento de undo separado como Oracle, guarda las versiones anteriores de las filas directamente en el heap de la tabla. Es una decisión de diseño más limpia en teoría, pero tiene una consecuencia concreta: si esas versiones antiguas no se limpian periódicamente, la tabla crece sin control. Eso es lo que hace el proceso VACUUM, que no existe en Oracle precisamente porque Oracle resolvió el problema de otra manera \parencite{postgresql_docs}.

Su otra limitación conocida es el modelo de un proceso por conexión. En aplicaciones con cientos de conexiones simultáneas esto puede saturar el sistema operativo, lo que explica por qué herramientas como PgBouncer existen y son tan usadas en producción.

\subsection{MySQL / InnoDB}

MySQL construyó su reputación en entornos web y en ese contexto funciona bien. Es más simple de configurar que Oracle y su rendimiento en lecturas es sólido. El problema es que esa simpleza tiene límites: en escenarios con escrituras concurrentes complejas, el \textit{gap locking} de InnoDB puede generar bloqueos que no son intuitivos y que son difíciles de diagnosticar si no se conoce bien el motor \parencite{mysql_docs}.

Su historia de múltiples motores de almacenamiento intercambiables también dejó inconsistencias que persisten. No todos los motores soportaban transacciones, no todos soportaban llaves foráneas, y aunque InnoDB resolvió la mayor parte de eso, la percepción de MySQL como motor "menos serio" para aplicaciones críticas tiene algo de base histórica.

\subsection{Microsoft SQL Server}

SQL Server es una opción sólida cuando el entorno ya es predominantemente Microsoft. Su integración con herramientas de BI como SSRS y SSIS, junto con características como In-Memory OLTP, lo hacen muy completo para escenarios empresariales. SQLOS, su scheduler interno, le da un nivel de control sobre el uso de CPU que otros motores no tienen \parencite{sqlserver_docs}.

La desventaja más evidente es el costo, comparable al de Oracle en ediciones Enterprise. Además, aunque existe una versión para Linux, SQL Server sigue siendo una plataforma pensada para Windows. En infraestructuras donde Linux es el estándar, eso genera fricciones que no son solo técnicas sino también organizacionales.

\clearpage