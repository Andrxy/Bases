% ============================================================
%  TEMA 1 — Historia y desarrollo de las bases de datos
%           hasta el modelo relacional
% ============================================================
\chapter{Historia y desarrollo de las bases de datos hasta el modelo relacional}

\section{Sistemas de archivos tradicionales}

Antes de que existieran los SGBD, los datos se gestionaban con archivos independientes procesados por aplicaciones específicas. Cada programa conocía la estructura exacta de sus archivos y los manipulaba directamente. Esto funcionaba mientras las aplicaciones eran pocas y simples, pero escalaba muy mal.

Los problemas eran predecibles: datos duplicados en múltiples archivos que se desincronizaban, programas que dejaban de funcionar cuando se cambiaba la estructura de un archivo, y ningún mecanismo real para que dos usuarios accedieran al mismo dato al mismo tiempo sin pisarse \parencite{silberschatz_2019}. No había una capa central que organizara nada.

\section{Modelo jerárquico}

La primera solución estructurada fue organizar los datos como un árbol: registros padre con registros hijo. El ejemplo más conocido es el \textbf{IBM IMS}, desarrollado en los años 60 para la NASA y adoptado ampliamente en la industria \parencite{mcgee_1977}.

Funcionaba bien para datos que naturalmente tienen esa estructura, como una orden de compra con sus líneas de detalle. El problema era cuando la realidad no encajaba en un árbol. Las relaciones muchos-a-muchos no se podían representar de forma directa, y navegar el modelo requería conocer exactamente la jerarquía predefinida.

\section{Modelo en red (CODASYL)}

El modelo en red, formalizado por el comité CODASYL a finales de los 60 \parencite{codasyl1971}, intentó resolver esa limitación. En lugar de un árbol, los datos se organizaban como un grafo: un registro podía tener múltiples padres. El diseñador detrás del concepto fue Charles Bachman con su sistema IDS.

Era más flexible que el modelo jerárquico, pero seguía dependiendo de punteros físicos entre registros. Para consultar datos había que navegar manualmente esos punteros en el código de la aplicación. Un cambio en la estructura física del modelo obligaba a reescribir los programas.

\section{Problemas compartidos de ambos modelos}

Tanto el modelo jerárquico como el en red tenían el mismo defecto fundamental: la \textbf{dependencia estructural}. Los programas estaban acoplados a la organización física de los datos. Si se quería reorganizar cómo se almacenaba algo, había que modificar todas las aplicaciones que lo usaban. Y la redundancia de datos seguía siendo un problema porque no había un mecanismo central que la controlara \parencite{silberschatz_2019}.

\section{La propuesta relacional de Edgar F. Codd}

En 1970, Edgar F. Codd, investigador de IBM, publicó el artículo \textit{``A Relational Model of Data for Large Shared Data Banks''} \parencite{codd_1970}. La propuesta era organizar los datos en tablas y permitir consultarlos con un lenguaje declarativo basado en álgebra relacional.

Lo más importante no era la estructura tabular en sí, sino la separación entre lo lógico y lo físico. El usuario o programador describe qué datos quiere, no cómo ir a buscarlos. El sistema se encarga del resto. Eso elimina de raíz la dependencia estructural que hacía tan frágiles a los modelos anteriores.

\section{SQL como lenguaje estándar}

El lenguaje que hizo operativa la propuesta de Codd fue SQL, desarrollado originalmente en IBM bajo el nombre SEQUEL \parencite{chamberlin1974sequel}. Su estandarización por ANSI/ISO en 1986 fue el factor que consolidó el modelo relacional en la industria: ya no importaba qué gestor usaras, el mismo SQL servía en todos.

\section{Aparición de los primeros SGBD comerciales}

El primer sistema relacional de investigación fue \textbf{System R} de IBM \parencite{astrahan1976}, que demostró que el modelo era implementable en la práctica. A partir de ahí llegaron los productos comerciales: \textbf{Oracle V2} en 1979 y \textbf{IBM DB2} en 1983. La adopción masiva de ambos, sin embargo, tuvo que esperar a que el hardware se pusiera al día.