% ============================================================
%  TEMA 4 — Comparativa de estructuras físicas entre SGBD
% ============================================================
\chapter{Comparativa de estructuras físicas entre SGBD}

\section{Introducción a la comparativa}

Los cuatro gestores analizados, Oracle, PostgreSQL, MySQL y SQL Server, resolvieron los mismos problemas fundamentales: gestionar memoria, procesos, archivos y transacciones. Lo que los diferencia no es si lo hacen o no, sino \textit{cómo} lo hacen, y esas diferencias de diseño tienen consecuencias concretas en rendimiento, mantenimiento y costo.

% ── 4.1 Arquitectura de memoria ──────────────────────────────────────────────
\section{Diferencias en la arquitectura de memoria}

\subsection{Oracle Database}

Oracle divide su memoria en la \textbf{SGA} (compartida entre todos los procesos) y la \textbf{PGA} (privada por proceso servidor). La gestión puede ser automática mediante AMM o ASMM, lo que permite redistribuir memoria entre componentes según la carga \parencite{oracle_concepts_19c}.

\subsection{PostgreSQL}

PostgreSQL tiene un modelo de memoria más simple y delega parte de la gestión al sistema operativo. El parámetro \texttt{shared\_buffers} define el buffer compartido entre todos los procesos. PostgreSQL también aprovecha el \textit{OS page cache} para lecturas, por lo que la caché efectiva suele ser mayor que lo que indica ese parámetro solo.

Cada proceso backend tiene su propia \texttt{work\_mem} para operaciones de ordenamiento o hash join, y \texttt{wal\_buffers} actúa como buffer en memoria antes de escribir el WAL al disco \parencite{postgresql_docs}.

\subsection{MySQL / InnoDB}

En MySQL el componente central de memoria es el \textbf{InnoDB Buffer Pool}, controlado por \texttt{innodb\_buffer\_pool\_size}. Almacena tanto páginas de datos como de índices, y puede dividirse en múltiples instancias para reducir la contención en sistemas con alta concurrencia. También mantiene un \textbf{Log Buffer} donde acumula entradas de redo antes de escribirlas al disco \parencite{mysql_docs}.

\subsection{Microsoft SQL Server}

SQL Server gestiona su memoria mediante un único \textbf{Buffer Pool} dinámico administrado por el componente interno \textbf{SQLOS}. Crece y se reduce automáticamente dentro de los límites definidos por \texttt{max server memory}. El \textbf{Plan Cache} almacena los planes de ejecución compilados, equivalente al library cache del Shared Pool de Oracle. Una característica distintiva es \textbf{In-Memory OLTP}, que permite definir tablas completamente residentes en memoria para operaciones transaccionales de muy alta velocidad \parencite{sqlserver_docs}.

% ── 4.2 Gestión de procesos ──────────────────────────────────────────────────
\section{Diferencias en la gestión de procesos}

\subsection{Oracle Database}

Oracle usa un modelo multi-proceso: cada conexión puede tener su propio proceso servidor dedicado, y los procesos de background (DBWR, LGWR, SMON, etc.) corren de forma independiente.

\subsection{PostgreSQL}

Sigue un modelo \textbf{multi-proceso puro}: por cada conexión, el proceso maestro \textbf{postmaster} crea un proceso hijo independiente del sistema operativo llamado \textit{backend}. Cien conexiones simultáneas implican cien procesos OS corriendo en paralelo.

La ventaja es el aislamiento: un backend que falla no compromete a los demás. La desventaja es el costo de crear y mantener muchos procesos, lo que en sistemas con miles de conexiones concurrentes puede ser pesado. Por eso herramientas como PgBouncer son comunes en producción \parencite{postgresql_docs}.

\subsection{MySQL / InnoDB}

Corre como un \textbf{único proceso} \texttt{mysqld} que maneja todas las conexiones mediante threads internos. Cada conexión recibe un thread. Los threads de background de InnoDB incluyen el \textit{master thread} para tareas de mantenimiento, los \textit{I/O threads} para operaciones asíncronas, los \textit{purge threads} que eliminan versiones antiguas de filas ya no necesarias por el MVCC, y los \textit{page cleaner threads} que escriben páginas sucias al disco \parencite{mysql_docs}.

\subsection{Microsoft SQL Server}

También corre como un único proceso (\texttt{sqlservr.exe}) con múltiples threads internos. Su característica distintiva es que \textbf{SQLOS} implementa un scheduler propio: los threads ceden el control voluntariamente en lugar de ser interrumpidos por el sistema operativo. Esto le da mayor control sobre la distribución de CPU \parencite{sqlserver_docs}.

% ── 4.3 Archivos físicos ─────────────────────────────────────────────────────
\section{Diferencias en la organización de archivos físicos}

\subsection{Oracle Database}

Oracle organiza sus datos en datafiles \texttt{.dbf} agrupados en tablespaces, acompañados por los control files y los redo log files organizados en grupos circulares.

\subsection{PostgreSQL}

Todo el almacenamiento vive bajo un directorio raíz llamado \textbf{PGDATA}. Dentro de él, cada base de datos tiene su propio subdirectorio identificado por un OID numérico, y cada tabla e índice es un archivo independiente. Cuando una tabla supera 1 GB, PostgreSQL la divide automáticamente en segmentos del mismo tamaño. El \textbf{WAL} vive en el directorio \texttt{pg\_wal} y funciona como el redo log de Oracle \parencite{postgresql_docs}.

\subsection{MySQL / InnoDB}

Ofrece dos modalidades. En la modalidad tradicional, todos los datos se guardan en un único archivo \textbf{ibdata1}. La modalidad recomendada actualmente es \texttt{innodb\_file\_per\_table}, donde cada tabla tiene su propio archivo \texttt{.ibd} con sus datos e índices \parencite{mysql_docs}.

\subsection{Microsoft SQL Server}

Usa una estructura clara: el archivo \textbf{.mdf} es el archivo de datos primario; los archivos \textbf{.ndf} son secundarios opcionales; y el archivo \textbf{.ldf} contiene el log de transacciones. Los archivos de datos se agrupan en \textbf{filegroups}, equivalentes a los tablespaces de Oracle. SQL Server también mantiene \textbf{TempDB}, una base de datos especial compartida por todas las bases del servidor para almacenamiento temporal \parencite{sqlserver_docs}.

% ── 4.4 Manejo de logs ───────────────────────────────────────────────────────
\section{Diferencias en el manejo de logs transaccionales}

Todos los gestores analizados comparten el mismo principio: los cambios se registran en un log \textit{antes} de aplicarse a los archivos de datos. Esto garantiza que ante una caída, el motor pueda reconstruir el estado correcto reproduciendo ese log.

\begin{table}[H]
  \centering
  \caption{Comparativa del mecanismo de logging transaccional}
  \label{tab:logging}
  \begin{tabular}{lp{2.8cm}p{2.8cm}p{2.8cm}p{2.8cm}}
    \toprule
    \textbf{Aspecto} & \textbf{Oracle} & \textbf{PostgreSQL} & \textbf{MySQL/InnoDB} & \textbf{SQL Server} \\
    \midrule
    Nombre del log       & Redo Log       & WAL (pg\_wal)      & InnoDB Redo Log       & Transaction Log (.ldf) \\
    Proceso escritor     & LGWR           & walwriter          & Log writer thread     & Log Writer thread \\
    Formato              & Circular (grupos) & Segmentos secuenciales & Circular (8.0+ dinámico) & VLF (Virtual Log Files) \\
    Archivado            & ARCn (Archive Log Mode) & pg\_archiver / streaming replication & Binary Log (distinto) & Log Backup \\
    PITR                 & Sí (RMAN)      & Sí (pg\_basebackup + WAL) & Sí (binlog + backup) & Sí \\
    \bottomrule
  \end{tabular}
  \\\small Fuente: Elaborado con IA a partir de documentación oficial.
\end{table}

% ── 4.5 Tabla resumen comparativa ───────────────────────────────────────────

\begin{landscape}
\begin{table}[H]
  \centering
  \caption{Comparativa general de estructuras físicas e internas de los SGBD}
  \label{tab:comparativa_general}
  \small
  \begin{tabular}{lp{3cm}p{3cm}p{3cm}p{3cm}}
    \toprule
    \textbf{Característica}      & \textbf{Oracle Database} & \textbf{PostgreSQL} & \textbf{MySQL (InnoDB)} & \textbf{SQL Server} \\
    \midrule
    \textbf{Arquitectura de memoria}
      & SGA (compartida) + PGA (privada). AMM/ASMM.
      & shared\_buffers + work\_mem. Apoya en OS page cache.
      & InnoDB Buffer Pool con instancias múltiples.
      & Buffer Pool dinámico. SQLOS. In-Memory OLTP. \\[6pt]

    \textbf{Modelo de procesos}
      & Multi-proceso con procesos background dedicados.
      & Multi-proceso (un proceso OS por conexión).
      & Mono-proceso con threads internos.
      & Mono-proceso (sqlservr.exe) con SQLOS y worker threads. \\[6pt]

    \textbf{Archivos de datos}
      & Datafiles (.dbf) agrupados en Tablespaces.
      & Archivos por relación en PGDATA/base/OID.
      & ibdata1 global o .ibd por tabla (file-per-table).
      & .mdf (primario) + .ndf (secundarios) en Filegroups. \\[6pt]

    \textbf{Log transaccional}
      & Redo Log circular (grupos). LGWR. Archivado opcional.
      & WAL (pg\_wal). walwriter. Archivado continuo.
      & InnoDB Redo Log + Binary Log (separados).
      & Transaction Log (.ldf) con VLF. \\[6pt]

    \textbf{Control de concurrencia}
      & MVCC con segmentos de Undo. Row-level locking.
      & MVCC nativo. Versiones antiguas en el heap de la tabla.
      & MVCC con undo tablespaces. Gap locking en índices.
      & Locking tradicional + MVCC vía versiones de fila en tempdb. \\[6pt]

    \textbf{Organización interna}
      & Bloques Oracle (2–32 KB). Segmentos/Extensiones.
      & Páginas de 8 KB. TOAST para valores grandes.
      & Páginas InnoDB de 16 KB. B+Tree clustered index.
      & Páginas de 8 KB. Extents de 64 KB. Heap o clustered. \\
    \bottomrule
  \end{tabular}
  \\\small Fuente: Elaborado con IA a partir de documentación oficial de cada SGBD.
\end{table}
\end{landscape}

\section{Ventajas y desventajas estructurales}

\subsection{Oracle Database}

Oracle es el motor más maduro del grupo. Características como RAC para clustering nativo o ASM para gestión de almacenamiento son el resultado de décadas resolviendo problemas reales en producción. Su sistema de recuperación ante fallos está muy bien desarrollado y documentado, lo que en entornos críticos es un argumento de peso.

El problema es que toda esa madurez tiene un precio. Administrar Oracle correctamente requiere conocimientos especializados que no son fáciles de conseguir ni baratos. Una instancia mal configurada consume recursos considerables incluso sin carga. Para organizaciones pequeñas o proyectos con presupuesto ajustado, Oracle puede ser más de lo que se necesita \parencite{greenwald_oracle}.

\subsection{PostgreSQL}

Lo que más llama la atención de PostgreSQL desde el punto de vista arquitectónico es su implementación del MVCC. En lugar de mantener un segmento de undo separado como Oracle, guarda las versiones anteriores de las filas directamente en el heap de la tabla. Es una decisión de diseño más simple en teoría, pero tiene una consecuencia concreta: si esas versiones antiguas no se limpian periódicamente, la tabla crece sin control. Eso es lo que hace el proceso VACUUM, que no existe en Oracle precisamente porque Oracle resolvió el problema de otra manera \parencite{postgresql_docs}.

Su otra limitación conocida es el modelo de un proceso por conexión. En aplicaciones con cientos de conexiones simultáneas esto puede saturar los recursos del sistema operativo, lo que explica por qué herramientas como PgBouncer son tan comunes en producción.

\subsection{MySQL / InnoDB}

MySQL construyó su reputación en entornos web y en ese contexto funciona bien: es más simple de configurar que Oracle y su rendimiento en lecturas es sólido. El problema es que en escenarios con escrituras concurrentes complejas, el \textit{gap locking} de InnoDB puede generar bloqueos que no son intuitivos y que son difíciles de diagnosticar sin conocer bien el motor \parencite{mysql_docs}.

\subsection{Microsoft SQL Server}

SQL Server es una opción sólida en entornos predominantemente Microsoft. Su integración con herramientas de BI y características como In-Memory OLTP lo hacen muy completo para escenarios empresariales. SQLOS le da un nivel de control sobre el uso de CPU que otros motores no tienen \parencite{sqlserver_docs}.

La desventaja más evidente es el costo, comparable al de Oracle en ediciones Enterprise. Además, aunque existe una versión para Linux, SQL Server sigue siendo una plataforma pensada para Windows, lo que en infraestructuras donde Linux es el estándar genera fricción.

\clearpage